package UnitTesting

import (
	"context"
	"database/sql"
	"fmt"
	"testing"

	"golang.org/x/crypto/bcrypt"

	"bytes"

	"net/http"
	"net/http/httptest"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/benzend/goalboard/pw"
	"github.com/benzend/goalboard/utils"
	"github.com/stretchr/testify/assert"

	"github.com/benzend/goalboard/routes"
)

// Hypothetical function that performs the query
func queryUser(ctx context.Context, username string) (int, string, string, error) {
	db, ok := ctx.Value(utils.CTX_KEY_DB).(*sql.DB)
	if !ok {
		return 0, "", "", fmt.Errorf("could not get database connection from context")
	}

	// This query must match the one expected in the test setup
	row := db.QueryRow("SELECT id, username, password FROM users WHERE username = ?", username)
	var id int
	var uname, password string
	err := row.Scan(&id, &uname, &password)
	if err != nil {
		return 0, "", "", err
	}
	return id, uname, password, nil
}

func TestRoutes(t *testing.T) {
	t.Run("UserRegister", func(t *testing.T) {
		db, mock, err := sqlmock.New()
		if err != nil {
			t.Fatalf("An error '%s' was not expected when opening a stub database connection", err)
		}
		defer db.Close()

		mock.ExpectQuery("SELECT id, username, password FROM users WHERE username = ?").
			WithArgs("testuser").
			WillReturnRows(sqlmock.NewRows([]string{"id", "username", "password"}).
				AddRow(1, "testuser", "testpass"))

		ctx := context.Background()
		ctxWithDB := context.WithValue(ctx, utils.CTX_KEY_DB, db)

		id, uname, pass, err := queryUser(ctxWithDB, "testuser")
		assert.NoError(t, err)
		assert.Equal(t, 1, id)
		assert.Equal(t, "testuser", uname)
		assert.Equal(t, "testpass", pass)

		assert.NoError(t, mock.ExpectationsWereMet())
	})
}
func TestUserRegistration(t *testing.T) {
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("failed to create mock database: %v", err)
	}
	defer db.Close()

	// Generate hashed password using bcrypt with a cost of 10
	hashedPassword, err := bcrypt.GenerateFromPassword([]byte("testpass"), 10)
	if err != nil {
		t.Fatalf("failed to generate hashed password: %v", err)
	}
	username := "testuser"

	// Set up expectation for the SQL query with hashed password
	mock.ExpectExec("INSERT INTO user_ \\(username, password\\) VALUES \\(\\$1, \\$2\\)").
		WithArgs(username, string(hashedPassword)).
		WillReturnResult(sqlmock.NewResult(2, 2))
	if _, err = db.Exec("INSERT INTO product_viewers (user_id, product_id) VALUES (?, ?)", username, hashedPassword); err != nil {
		return
	}
	// Create request body with username and hashed password
	reqBody := []byte(fmt.Sprintf(`{"username": "%s", "password": "%s"}`, username, hashedPassword))
	req, err := http.NewRequest("POST", "/register", bytes.NewBuffer(reqBody))
	if err != nil {
		t.Fatalf("failed to create HTTP request: %v", err)
	}

	rr := httptest.NewRecorder()
	ctx := context.Background()
	ctxWithDB := context.WithValue(ctx, utils.CTX_KEY_DB, db)
	routes.Register(ctxWithDB, rr, req)

	// Verify expectations and HTTP status code
	assert.NoError(t, mock.ExpectationsWereMet())
	if rr.Code != http.StatusOK {
		t.Errorf("expected status code %d but got %d", http.StatusOK, rr.Code)
	}
}

func TestUserLogin(t *testing.T) {
	// Create a mock database connection
	db, mock, err := sqlmock.New()
	if err != nil {
		t.Fatalf("failed to create mock database: %v", err)
	}
	defer db.Close()

	// Prepare the mock database response for the provided username
	username := "testuser"
	// Ensure that the hashed password matches the one generated by pw.HashPassword
	hashedPassword, err := pw.HashPassword("testpass")
	if err != nil {
		t.Fatalf("failed to hash password: %v", err)
	}
	userId := int64(123)
	mock.ExpectQuery("SELECT password, id FROM user_ WHERE username = ?").
		WithArgs(username).
		WillReturnRows(sqlmock.NewRows([]string{"password", "id", "username"}).AddRow(hashedPassword, userId, username))
}

// 	// Create a request body with user credentials
// 	requestBody := map[string]string{
// 		"username": username,
// 		"password": "testpass", // Use the plaintext password here
// 	}
// 	reqBody, err := json.Marshal(requestBody)
// 	if err != nil {
// 		t.Fatalf("failed to marshal request body: %v", err)
// 	}

// 	// Create a new HTTP request with the request body
// 	req, err := http.NewRequest("POST", "/login", bytes.NewBuffer(reqBody))
// 	if err != nil {
// 		t.Fatalf("failed to create request: %v", err)
// 	}

// 	// Create a mock response recorder
// 	rr := httptest.NewRecorder()

// 	// Create a context with the mock database connection
// 	ctx := context.WithValue(context.Background(), utils.CTX_KEY_DB, db)

// 	// Call the Login handler function with the mock context, request, and response recorder
// 	routes.Login(ctx, rr, req)

// 	// Check the response status code
// 	if rr.Code != http.StatusOK {
// 		t.Errorf("expected status code %d but got %d", http.StatusOK, rr.Code)
// 	}

// 	// Parse the response body and verify its contents
// 	var responseData routes.LoginReturnData
// 	err = json.Unmarshal(rr.Body.Bytes(), &responseData)
// 	if err != nil {
// 		t.Fatalf("failed to unmarshal response body: %v", err)
// 	}

// 	// Verify token and user data
// 	assert.NotEmpty(t, responseData.Token)
// 	assert.Equal(t, userId, responseData.User.ID)
// 	assert.Equal(t, username, responseData.User.Username)

// 	if t.Failed() {
// 		fmt.Println("TestLoginHandler failed")
// 	} else {
// 		fmt.Println("TestLoginHandler passed")
// 	}
// })

// t.Run("userLogOut", func(t *testing.T) {
// 	// Create a new HTTP request (GET /logout)
// 	req, err := http.NewRequest("GET", "/logout", nil)
// 	if err != nil {
// 		t.Fatal("failed to create request:", err)
// 	}

// 	// Create a mock response recorder
// 	rr := httptest.NewRecorder()

// 	// Create a context (no need for the database in this case)
// 	ctx := context.Background()

// 	// Call the Logout handler function with the mock context, response recorder, and request
// 	routes.Logout(ctx, rr, req)

// 	// Check the response status code
// 	if rr.Code != http.StatusSeeOther {
// 		t.Errorf("expected status code %d but got %d", http.StatusSeeOther, rr.Code)
// 	}

// 	// Check if the "jwt_token" cookie is cleared
// 	cookie := rr.Result().Cookies()[0]
// 	if cookie.Name != "jwt_token" || cookie.Value != "" || !cookie.Expires.Before(time.Now()) {
// 		t.Error("jwt_token cookie is not cleared or has incorrect attributes")
// 	}

// 	// Check if the response redirects to the login page
// 	location, err := rr.Result().Location()
// 	if err != nil {
// 		t.Fatal("failed to get redirect location:", err)
// 	}
// 	if location.Path != "/login" {
// 		t.Errorf("expected redirect location /login but got %s", location.Path)
